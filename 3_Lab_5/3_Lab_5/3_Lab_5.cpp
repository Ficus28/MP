#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>

using namespace std;

mutex mutex1;
mutex mutex2;

void threadFunction() {
    for (int i = 0; i < 10; ++i) {
        // Захватываем мьютекс mutex2 перед выводом строки дочернего потока
        mutex2.lock();
        cout << i + 1 << " строка текста дочернего потока" << endl;
        mutex2.unlock();
        this_thread::sleep_for(chrono::milliseconds(10));
    }
}

int main() {
    setlocale(LC_ALL, "Russian");
    thread myThread(threadFunction);

    for (int i = 0; i < 10; ++i) {
        // Захватываем мьютекс mutex1 перед выводом строки родительского потока
        mutex1.lock();
        cout << i + 1 << " строка текста родительского потока" << endl;
        mutex1.unlock();
        this_thread::sleep_for(chrono::milliseconds(10));
    }

    myThread.join();

    return 0;
}
//В коде 12 используются два мьютекса для синхронизации доступа к общему ресурсу (стандартному выводу cout). 
// Проблема возникает из-за того, что мьютексы не гарантируют порядок захвата и освобождения. 
// Это означает, что после того, как родительский поток освобождает мьютекс mutex1, ничто не мешает другому потоку 
// (в данном случае, дочернему) захватить его перед тем, как дочерний поток захватит mutex2, 
// что приведет к возможным конфликтам и неправильному порядку вывода.
//
//С другой стороны, в коде 14 используются два семафора-счетчика для синхронизации между родительским и дочерним потоками. 
// В этом случае использование семафоров-счетчиков обеспечивает порядок выполнения действий. 
// Каждый счетчик контролирует, сколько раз каждый поток выполнил свои действия. 
// Таким образом, порядок выполнения действий между потоками определяется явно, а не случайно, как при использовании мьютексов.
//
//
//Поэтому доказательство, применимое к мьютексам, не применимо к семафорам-счетчикам, 
// поскольку семафоры-счетчики гарантируют управление порядком выполнения действий между потоками.
