//Необходимо реализовать код, работающий без ошибок
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <iostream>

#define N 5//определяет макрос с именем N и значением 5. Это означает, 
//что во всем коде, где будет встречаться N, он будет заменен на число 5

HANDLE forks[N];//объявляет массив forks из N элементов типа HANDLE
int spaghettiCount = 10; // Предопределенное количество спагетти

void philosopher(LPVOID arg) {//представляет собой функцию philosopher, которая моделирует поведение одного из философов в задаче "Обедающие философы
    int id = *(int*)arg;
    int left_fork = id;
    int right_fork = (id + 1) % N;

    while (spaghettiCount > 0) {
        // Философ размышляет
        Sleep(rand() % 1000);//Функция Sleep приостанавливает выполнение потока на указанное количество миллисекунд.
        //rand() - это функция, которая генерирует псевдослучайное число

        // Философ пытается взять обе вилки одновременно
        if (left_fork < right_fork) {
            WaitForSingleObject(forks[left_fork], INFINITE);
            WaitForSingleObject(forks[right_fork], INFINITE);
            //Философ сначала пытается взять левую вилку, используя функцию WaitForSingleObject.
            //Функция WaitForSingleObject приостанавливает выполнение потока, пока вилка не станет доступной.
            //Затем философ пытается взять правую вилку, используя ту же функцию
            //Функция WaitForSingleObject будет ждать бесконечно (INFINITE), пока вилка не станет доступной
        }
        else {
            WaitForSingleObject(forks[right_fork], INFINITE);//правая вилка
            WaitForSingleObject(forks[left_fork], INFINITE);//левая вилка
        }

        // Философ взял обе вилки и начинает есть
        if (spaghettiCount > 0) {
            printf("Философ %d начал есть\n", id);
            Sleep(rand() % 1000);
            printf("Философ %d закончил есть\n", id);
            --spaghettiCount;//уменьшение значения оставшегося спагетти
        }

        // Философ освобождает вилки
        ReleaseMutex(forks[left_fork]);//левая вилка
        ReleaseMutex(forks[right_fork]);//правая вилка
    }
}

int main() {
    setlocale(LC_ALL, "Russian");//руссификатор
    HANDLE philosophers[N];
    int ids[N];
    //philosophers - массив дескрипторов синхронизации типа HANDLE.
    //ids - массив целых чисел.

    // Инициализация вилок
    for (int i = 0; i < N; ++i) {
        forks[i] = CreateMutex(NULL, FALSE, NULL);//создается массив forks для хранения дескрипторов мьютексов
    }

    // Создание потоков для философов
    for (int i = 0; i < N; ++i) {
        ids[i] = i;
        philosophers[i] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)philosopher, &ids[i], 0, NULL);//строка создает новый поток с помощью функции CreateThread
        //Переменная i используется как счетчик для перебора элементов массивов ids и philosophers
    }

    // Ожидание завершения работы философов
    WaitForMultipleObjects(N, philosophers, TRUE, INFINITE);//Данный код ждет завершения всех N потоков, созданных в задаче "Обедающие философы"

    // Уничтожение вилок
    for (int i = 0; i < N; ++i) {
        CloseHandle(forks[i]);//Данный код закрывает мьютекс, который представляет собой вилку i в задаче "Обедающие философы"
    }

    return 0;
}
//HANDLE - это тип данных, который используется для представления объектов Windows, таких как файлы, процессы, потоки и т.д.
//forks - это имя массива.
//N - это размер массива, который должен быть определен ранее.
//[] - это оператор объявления массива.
// 
//LPVOID arg - это формальный параметр функции, который используется для передачи идентификатора философа.
//int left_fork - это локальная переменная, которая хранит номер вилки слева от философа.
//int right_fork - это локальная переменная, которая хранит номер вилки справа от философа.
//% -это оператор остатка от деления.
//
//WaitForSingleObject - это функция Windows API, которая приостанавливает выполнение потока, пока не произойдет определенное событие.
//forks - это массив дескрипторов синхронизации, где каждый дескриптор представляет собой вилку.
//left_fork - это номер вилки слева от философа.
//right_fork - это номер вилки справа от философа.
//INFINITE - это константа, которая означает, что функция WaitForSingleObject должна ждать бесконечно долго, пока не произойдет событие.
//
//ReleaseMutex - это функция Windows API, которая используется для освобождения мьютекса.
//forks - это массив дескрипторов синхронизации, где каждый дескриптор представляет собой вилку.
//left_fork - это номер вилки слева от философа.
//right_fork - это номер вилки справа от философа.
// 
//CreateMutex - это функция Windows API, которая используется для создания мьютекса.
//NULL - это первый параметр функции CreateMutex, который указывает на атрибуты безопасности по умолчанию.
//FALSE - это второй параметр функции CreateMutex, который указывает, что мьютекс не будет изначально владеть ни одним потоком.
//NULL - это третий параметр функции CreateMutex, который указывает на имя мьютекса.
//
//Параметры функции CreateThread:
//NULL: Первый параметр указывает на атрибуты безопасности по умолчанию.
//0 : Второй параметр указывает на размер стека потока(0 - значение по умолчанию).
//(LPTHREAD_START_ROUTINE)philosopher: Третий параметр указывает на функцию, которую будет выполнять поток.Здесь она приводится к типу LPTHREAD_START_ROUTINE, 
// который является указателем на функцию с определенной сигнатурой.В данном случае, этой функцией является philosopher.
//
//& ids[i] : Четвертый параметр указывает на аргумент, который будет передан функции philosopher.Здесь передается адрес элемента массива ids с индексом i.
//0 : Пятый параметр указывает на флаги создания потока(0 - значение по умолчанию).
//NULL : Шестой параметр указывает на идентификатор потока(не используется).
//
//WaitForMultipleObjects: Функция Windows API, которая используется для ожидания одного или нескольких событий.
//N : Первый параметр функции WaitForMultipleObjects, который указывает на количество объектов, за которые будет идти ожидание.
//philosophers : Второй параметр, массив дескрипторов синхронизации(в данном случае, мьютексов).
//TRUE : Третий параметр, который указывает, что функция должна ждать завершения всех N потоков.
//INFINITE : Четвертый параметр, который указывает, что функция должна ждать бесконечно долго.
//
//CloseHandle: Функция Windows API, которая используется для закрытия дескриптора синхронизации.
//forks[i] : Первый параметр функции CloseHandle, который указывает на дескриптор синхронизации, который необходимо закрыть.В данном случае это дескриптор мьютекса из массива forks с индексом i